\documentclass{article}
\usepackage[a4paper, top=3cm, bottom=3cm]{geometry}
\usepackage{setspace}
\usepackage{fancyhdr}
\usepackage{tocloft}
\usepackage[utf8x]{inputenc}
\usepackage[english]{babel}
\usepackage{url,graphicx,tabularx,array,geometry}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{tikz}
\usepackage{listings}
\usepackage{courier}
\usepackage{caption}
\usepackage{titlesec}

\titleformat{\section}{\bf\Large\sffamily}{\thesection}{1em}{}  
\titleformat{\subsection}{\bf\large\large\sffamily}{\thesubsection}{1em}{}  

\lstset{
         basicstyle=\footnotesize\ttfamily, % Standardschrift
         %numbers=left,               % Ort der Zeilennummern
         numberstyle=\tiny,          % Stil der Zeilennummern
         %stepnumber=2,               % Abstand zwischen den Zeilennummern
         numbersep=5pt,              % Abstand der Nummern zum Text
         tabsize=2,                  % Groesse von Tabs
         extendedchars=true,         %
         breaklines=true,            % Zeilen werden Umgebrochen
         keywordstyle=\color{red},
    		frame=b,         
 %        keywordstyle=[1]\textbf,    % Stil der Keywords
 %        keywordstyle=[2]\textbf,    %
 %        keywordstyle=[3]\textbf,    %
 %        keywordstyle=[4]\textbf,   \sqrt{\sqrt{}} %
         stringstyle=\color{white}\ttfamily, % Farbe der String
         showspaces=false,           % Leerzeichen anzeigen ?
         showtabs=false,             % Tabs anzeigen ?
         xleftmargin=17pt,
         framexleftmargin=17pt,
         framexrightmargin=5pt,
         framexbottommargin=4pt,
         %backgroundcolor=\color{lightgray},
         showstringspaces=false      % Leerzeichen in Strings anzeigen ?        
 }
 \lstloadlanguages{% Check Dokumentation for further languages ...
         %[Visual]Basic
         %Pascal
         %C
         %C++
         %XML
         %HTML
         Java
 }

\DeclareCaptionFont{white}{\color{white}\sffamily}
\DeclareCaptionFormat{listing}{\colorbox[cmyk]{0.43, 0.35, 0.35,0.01}{\parbox{\textwidth}{\hspace{15pt}#1#2#3}}}
\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white, singlelinecheck=false, margin=0pt, font={bf,footnotesize}}

\def\ma{\textsc{Mason}}
\def\dm{\textsc{D-Mason}}

\begin{document}
\pagestyle{empty}
\sffamily
\title{\dm\: a tutorial}
\author{\url{http://www.isislab.it/projects/dmason}}
\maketitle

% Set arabic (1,2,3...) page numbering
\pagenumbering{arabic}


\section{Introduction}
We present a framework, \dm, that is a distributed version of  \ma, a well-known and popular library for writing and running Agent-based simulations. \dm\ introduces the parallelization at framework level so that scientists that use the framework (domain expert but with limited knowledge of distributed programming) can be only minimally aware of such distribution. 

In this document, in particular, we provide a step-by-step guide to the process of ``parallelization'' of the Particle example from \ma\ by using \dm.
\begin{figure}[ht]
	\centering
		\includegraphics[width=0.5\textwidth, bb=0 0 470 520]{particles.png}	
		\caption{GUIState for \texttt{Particle} simulation}
	\label{fig:p01}
\end{figure}

\section{Acknowledgements}
\dm\ contains work by (in alphabetical order): \textit{Michele Carillo, Gennaro Cordasco, Rosario De Chiara, Fabio Fulgido, Ada Mancuso, Dario Mazzeo, Francesco Raia, Vittorio Scarano, Flavio Serrapica, Carmine Spagnuolo, 
Luca Vicidomini, Mario Vitale.}

\section{Structure}
The starting point is the package \texttt{Particles} is composed by three classes, as it can be found in the original MASON distribution:

\begin{itemize}
	\item \texttt{Particle:} it implements the agent that will be simulated by the application.
	\item \texttt{Particles:} it represents the simulation environment: it allows to run the simulation from the command line without using a GUI.
	\item \texttt{ParticlesWithUI:} it allows to run simulations with a GUI, as depicted in the Figure \ref{fig:p01}.
\end{itemize}

Similarly, in D-MASON, there will be the package \texttt{DParticles} containing the following classes:
\begin{itemize}
	\item \texttt{RemoteParticle:} it is an abstract class, implementing \texttt{RemoteAgent} and containing the remote ID of the agent in the field and its position. 
	\item \texttt{DParticle:} it extends \texttt{RemoteParticle} and implements the \texttt{distributed} agent that will be simulated by the application.
	\item \texttt{DParticles:} it represents the \texttt{distributed} simulation environment: it allows to run the simulation from the command line without using a GUI.
	\item \texttt{DParticlesWithUI:} it allows to run simulations with a GUI that is aware of the \texttt{distributed} environment.
\end{itemize}

\section{From \texttt{Particle} to \texttt{DParticle}}
The original \texttt{Particle} has to implement the \texttt{Steppable} interface and, in particular, the method \texttt{step()}, containing the agent logic. In the same way \texttt{RemoteParticle} is an abstract class that has to implement \texttt{RemoteAgent}, that is the D-MASON interface containing the necessary logic for the distributed agent. Finally \texttt{DParticle} extends \texttt{RemoteParticle} and implements the logic of the agent.

\texttt{RemoteAgent} is parameterized with an \texttt{Int2D} object-type because, in this simulation, the field has this specific type to indicate locations, and allows programmers to set, for each agent, an unique identifier and a field position.
A \texttt{Particle} simply contains two integer parameters, \texttt{xdir} and \texttt{ydir}, for setting the initial direction that the particle will move along.

\lstset{language=Java,caption={Class Particle},label=particle1}
\begin{lstlisting}
...
  public Particle(int xdir, int ydir) {
   public boolean randomize = false;
   this.xdir = xdir;
   this.ydir = ydir;
  }
...
\end{lstlisting}


\texttt{DParticle} has two constructors: the first is empty and it has been introduced for a future implementation of the method \texttt{clone()}, and the second one has as parameter a subclass of the abstract class \texttt{DistributedState}.

\lstset{language=Java,caption={Class DParticle},label=dparticle1}
\begin{lstlisting}
public class DParticle extends RemoteParticle<Int2D>
{
   public int xdir;  // -1, 0, or 1
   public int ydir;  // -1, 0, or 1

   public DParticle(){ }
   
   public DParticle(DistributedState state)
   {
     super(state);
   }
\end{lstlisting}

In order to distribute a MASON simulation it is necessary to change some parts of the agent logic. In the original MASON version each particle, on each step, performs a collision avoidance routine by checking whether the location it is moving to is already occupied by another particle or not. 

\lstset{language=Java,caption={Class Particle},label=particle2}
\begin{lstlisting}
   ...
  public void step(SimState state) {
   ...
   if (randomize) {
    xdir = tut.random.nextInt(3) - 1;
    ydir = tut.random.nextInt(3) - 1;
	  randomize = false;
   }
   ...
   // set my new location
   Int2D newloc = new Int2D(newx,newy);
   tut.particles.setObjectLocation(this,newloc);
   
   // randomize everyone at that location if need be
   Bag p = tut.particles.getObjectsAtLocation(newloc);
   if (p.numObjs > 1) {
   for(int x=0;x<p.numObjs;x++)
       ((Particle)(p.objs[x])).randomize = true;
   }
  }
}
\end{lstlisting}

The distributed version is slightly different because it first check if the new location is occupied and, in this case, it randomizes its direction and move to the new location by using the method \texttt{setDistributedObjectLocation}.

%In a distributed environment different particles cannot do this check in different steps, as in the original version, but they first check for collision, using the same MASON method, then they set the new field location, using \texttt{setDistributedObjectLocation}. 

\lstset{language=Java,caption={Class DParticle},label=dparticle2}
\begin{lstlisting}
public void step(SimState state)
{
 DParticles tut = (DParticles)state;
 Int2D location = tut.particles.getObjectLocation(this);
 Bag p = tut.particles.getObjectsAtLocation(location);
 tut.trails.setDistributedObjectLocation(1.0, location,state);
 if (p.numObjs > 1)
 {
   xdir = tut.random.nextInt(3) - 1; 
   ydir = tut.random.nextInt(3) - 1;
 }
 int newx = location.x + xdir;
 int newy = location.y + ydir;
 if (newx < 0) { newx++; xdir = -xdir; } 
 else if (newx >= tut.trails.getWidth()) {newx--; xdir = -xdir; }
 if (newy < 0) { newy++ ; ydir = -ydir; }
 else if (newy >= tut.trails.getHeight()) {newy--; ydir = -ydir; }
 Int2D newloc = new Int2D(newx,newy);
 tut.particles.setDistributedObjectLocation(newloc, this, state);
 }
}
\end{lstlisting}


\section{From \texttt{Particles} to \texttt{DParticles}}
\texttt{Particles} extends the \texttt{SimState} class  while \texttt{DParticles} extends \texttt{DistributedState}, parameterized with \texttt{Int2D} object-type.

DParticles contains three other variables indicating, respectively, width and height of the field and the way of partitioning the field (that can be one or two dimensional, as shown in Figure \ref{fig:dp01}). \texttt{Particles} has just one constructor that has as parameter the random generator seed while \texttt{DParticles} constructor has as input an objects array, containing several parameters specific for the distributed simulation (e.g. network address, port, etc \ldots). 

In \texttt{Particles} there are two fields, the first containing the agents, the second one containing the trails. The creation of the fields and the placement of the agents in them are carried out by a simple loop that instantiates new particles with a random position and direction and place them in the proper field. 

In order to add particles to the schedule, it is possible to use \texttt{scheduleRepeating()}, that allows to schedule agents repeatedly, and to add particles to the field there is \texttt{setObjectLocation()}. In \texttt{DParticles} there is the method \texttt{createDSparseGrid2D} of the class \texttt{DSparseGrid2DFactory} for creating a new distributed field. Note that it is necessary to use a factory to choose the kind of field partition. The agent initial position is computed by the method \texttt{setAvailableRandomLocation()} and to add particles in the schedule it is necessary to use the method \texttt{scheduleOnce()}, because in the next step a certain agent could not stay in the same part of the field, so using \texttt{scheduleRepeating()} will not delete the particle from the schedule. Finally there are other three new methods: a \texttt{getter} method for returning the subclass of the \texttt{DistributedState}, a method for adding an agent with a given position in the field, a method for attaching a portrayal to an agent.

\lstset{language=Java,caption={Class Particles},label=particles}
\begin{lstlisting}
public class Particles extends SimState  {
  public DoubleGrid2D trails;
  public SparseGrid2D particles;
  ...
  public Particles(long seed) {
      super(seed);
  }
  
  public void start() {
   ...
   for(int i=0 ; i<numParticles ; i++) {
     p = new Particle(random.nextInt(3) - 1, random.nextInt(3) - 1);  // random direction
     schedule.scheduleRepeating(p);
     ...
     particles.setObjectLocation(p,new Int2D(x,y));  // random location
   }
  }
  
  public static void main(String[] args) {
    doLoop(Particles.class, args);
    System.exit(0);
  }
}
\end{lstlisting}

\lstset{language=Java,caption={Class DParticles},label=dparticles}
\begin{lstlisting}
public class DParticles extends DistributedState<Int2D> {
private static boolean isToroidal=false;
public DSparseGrid2D particles;
public DDoubleGrid2D trails;
public int gridWidth ;
public int gridHeight ;
public int MODE;

public DParticles(Object[] params)
{
 super((Integer)params[2],(Integer)params[3],(Integer)params[4],
 (Integer)params[7], (Integer)params[8], (String)params[0],
 (String)params[1],(Integer)params[9], isToroidal,
 new DistributedMultiSchedule<Int2D>());
 ip = params[0]+"";
 port = params[1]+"";
 this.MODE=(Integer)params[9];
 gridWidth=(Integer)params[5];
 gridHeight=(Integer)params[6];
}

public void start()
{
 super.start();
 try
{
 trails = DDoubleGrid2DFactory.createDDoubleGrid2D(gridWidth,
  gridHeight, this, super.MAX_DISTANCE, TYPE.pos_i,
  TYPE.pos_j, super.NUMPEERS, MODE,0, false, "trails");

 particles = DSparseGrid2DFactory.createDSparseGrid2d(gridWidth,
  gridHeight, this, 
  super.MAX_DISTANCE, TYPE.pos_i,
  TYPE.pos_j,super.NUMPEERS,MODE, "particles");

 init_connection();
}catch (DMasonException e) { e.printStackTrace();}
 DParticle p=new DParticle(this);
 while(particles.size() != super.NUMAGENTS)
{
 particles.setAvailableRandomLocation(p);
 p.xdir = random.nextInt(3)-1;
 p.ydir = random.nextInt(3)-1;
 if(particles.setDistributedObjectLocationForPeer(new Int2D
   (p.pos.getX(),p.pos.getY()), p, this))
 {
 schedule.scheduleOnce(schedule.getTime()+1.0,p);
 if(particles.size() != super.NUMAGENTS)
 p=new DParticle(this);
 }
}
 Steppable decreaser = new Steppable()
{
 public void step(SimState state)
{
 trails.multiply(0.9);
}
 static final long serialVersionUID = 6330208160095250478L;
};
 schedule.scheduleRepeating(Schedule.EPOCH,2,decreaser,1);
try
{
 getTrigger().publishToTriggerTopic("Simulation cell "+particles.cellType+" ready...");
 } catch (Exception e) {
 e.printStackTrace();
 }
}

public static void main(String[] args)
{
 doLoop(DParticles.class, args);
 System.exit(0);
}
static final long serialVersionUID = 9115981605874680023L;

public DistributedField getField()
{
 return particles;
}

public SimState getState()
{
 return this;
}

public void addToField(RemoteAgent<Int2D> rm,Int2D loc)
{
 particles.setObjectLocation(rm, loc);
}

public boolean setPortrayalForObject(Object o)
 {
 return false;
 }
}

\end{lstlisting}

\section{From \texttt{ParticlesWithUI} to \texttt{DParticlesWithUI}}
\begin{figure}
\centering
\includegraphics[width=0.4\textwidth,bb=0 0 470 520]{particles-h.png} 
\includegraphics[width=0.4\textwidth,bb=0 0 470 520]{particles-m.png}
\caption{Respectively \texttt{HORIZONTAL} and \texttt{SQUARE} partition mode.}
\label{fig:dp01}
\end{figure}
There are few differences between original \texttt{ParticlesWithUI} and the its distributed version, \texttt{DParticlesWithUI}. They both extend the class \texttt{GUIState}, responsible of instantiating all graphics elements; \texttt{DParticlesWithUI} has a constructor for passing to \texttt{DParticles} the objects array and it has to store in a \texttt{String} the \texttt{region} identifier, in order to show which region it is simulating (e.g. \texttt{0-0} means the upper-left part of the grid partitioned field).
\lstset{language=Java,caption={Class ParticlesWithUI},label=particleswui}
\begin{lstlisting}
public class ParticlesWithUI extends GUIState {
...
public static void main(String[] args) {
ParticlesWithUI t = new ParticlesWithUI();
t.createController();
}
public ParticlesWithUI() { 
super(new Tutorial3(System.currentTimeMillis()));
}
public ParticlesWithUI(SimState state){
super(state);
}
...
}
\end{lstlisting}

\lstset{language=Java,caption={Class \texttt{DParticlesWithUI}},label=dparticleswui}
\begin{lstlisting}
public class DParticlesWithUI extends GUIState {
...
public static String name;
...
public DParticlesWithUI(Object[] args) {
super(new DParticles(args));
name = String.valueOf(
args[7])+""+(String.valueOf(args[8]));
}
public static String getName() { return "Peer: <"+name+">"; }
...
}
\end{lstlisting}

\section{Load balancing for Grid partition}

\section{Introduction}
As described before \dm\ uses a space partitioning approach where the fields are subdivided in regions assigned to workers; this approach allows to limit the communication among the workers. Indeed, since each agent interacts only within a small area around it, the communication is limited to local messages (messages between workers, managing neighboring spaces, etc.). 

The problem with this approach is that agents can migrate between regions and consequently the association between workers and agents changes during the simulation. Moreover, load balancing is not guaranteed and needs to be addressed by the application.

\subsection{The balancing mechanism}
The balancing mechanism is quite simple: when a region is overloaded it decides to split itself in smaller regions, dividing consequently the amount of agents in each of these regions. 

Two important factors have an impact on the efficiency of this decision: when to split and how to split.

Each region during the simulation compares the number $r$ of agents it is simulating with the average number $a$ of agents simulated by its neighbors. When these $r > k_s \times a$ then the load balancing kicks in splitting the overloaded region in $9$ subregions as depicted in \ref{fig:lb}: $8$ will go to neighbors of the overloaded region and it will be in charge just for the central one. 

As along as the inequality stands the region stays split; whenever $r < k_m \times a$ the subregions are called back to its original region. 

It is worth noting that the both the split and the merge are computational expensive operations so deciding the factors $k_s$ and $k_m$ is a key point in the performances of the whole system.

\begin{figure}
\centering
\includegraphics[width=0.4\textwidth, bb=0 0 1302 827]{LoadBalancing.png}
\caption{Example of load balancing for grid partition mode. \label{fig:lb}}
\end{figure}

\subsection{Parameters for load balancing}
In this section it is explained how to set the parameters for the load balancing in \texttt{DParticles}. The factor $k_s$ is the variable \texttt{thresholdSplit} and specifies while $k_m$ is the simulation parameter \texttt{thresholdMerge}.

\lstset{language=Java,caption={Class \texttt{DParticles}},label=dparticles}
\begin{lstlisting}
 public DParticles(Object[] params)
    {    	
    	...
    	gridWidth = (Integer)params[5];
    	gridHeight = (Integer)params[6];
    	((DistributedMultiSchedule)schedule).setThresholdMerge(1);
        ((DistributedMultiSchedule)schedule).setThresholdSplit(5);

    }    
\end{lstlisting}

\subsection{How to use Master’s GUI with load balancing}
For load balancing the textbox WIDTH and the textbox HEIGHT must contain the same value and this value must be divided by $3 * sqrt(REGIONS)$. For example if the regions are $16$  the value of the textbox must be divided by $3 * 4 = 12$.  For enable the load balancing there is a checkbox to set, see \ref{fig:masterlb}. Remember that the regions must be at least $9$ because of type of load balancing.
\begin{figure}
\centering
\includegraphics[width=1.3\textwidth, bb=0 0 1012 520]{JMasterUI.png}
\caption{Master GUI. \label{fig:masterlb}}
\end{figure}

\section{System Management}

\subsection{Introduction}
In this section it is explained the system management functionalities, in detail:

\begin{itemize}
	\item Peer auto reconnection
		\begin{itemize}
		\item Automatic reconnection when the comunication server(CS) is restarted after a failure 
		\end{itemize}
	 \item Restart simulation
		\begin{itemize}
		\item Restart simulation without restart the CS (eg launch another simulation) 
		\end{itemize}
\end{itemize}

\subsection{ Peer auto reconnection}
This feature requires no change.

\subsection{Restart simulation}

To enable the functionality of simulation reset it is necessary to edit the ActiveMQ configuration file.

\begin{itemize}
	\item Windows\\ 
The file to edit is "wrapper.conf" located in:

\lstset{language=Java}
\begin{lstlisting}	
		%ACTIVEMQ_BASE%\bin\win32 or %ACTIVEMQ_BASE%\bin\win64
\end{lstlisting}
It is necessary to uncomment this line

\lstset{language=Java,caption={File \texttt{wrapper.conf}},label=wrapper.conf}
\begin{lstlisting}
  	
    	...
    	# Uncomment to enable jmx
	#wrapper.java.additional.n=-Dcom.sun.management.jmxremote.port=1616
	#wrapper.java.additional.n=-Dcom.sun.management.jmxremote.authenticate=false
	#wrapper.java.additional.n=-Dcom.sun.management.jmxremote.ssl=false

 
\end{lstlisting}

and then replace the "n" with the next number from the previous section

\lstset{language=Java,caption={File \texttt{wrapper.conf}},label=wrapper.conf}
\begin{lstlisting}
	...
	wrapper.java.additional.10=-Dactivemq.conf=%ACTIVEMQ_CONF%
	wrapper.java.additional.11=-Dactivemq.data=%ACTIVEMQ_DATA%
\end{lstlisting}
In this case we obtain this
\lstset{language=Java,caption={File \texttt{wrapper.conf}},label=wrapper.conf}
\begin{lstlisting}
	...
	# Uncomment to enable remote jmx
	wrapper.java.additional.12=-Dcom.sun.management.jmxremote.port=1616
	wrapper.java.additional.13=-Dcom.sun.management.jmxremote.authenticate=false
	wrapper.java.additional.14=-Dcom.sun.management.jmxremote.ssl=false
\end{lstlisting}

\item Linux\\
The file to edit is "activemq" located in:
\lstset{language=Java}
\begin{lstlisting}	
		%ACTIVEMQ_HOME%/bin/
\end{lstlisting}
It is necessary to unccoment this line

\lstset{language=Java,caption={File \texttt{activemq}},label=activemq}
\begin{lstlisting}
	...
	#
	# ACTIVEMQ_SUNJMX_START=''-Dcom.sun.management.jmxremote.port=11099 ''
	# ACTIVEMQ_SUNJMX_START=''\$ACTIVEMQ_SUNJMX_START -Dcom.sun.management.jmxremote.password.file=\${ACTIVEMQ_CONF}/jmx.password ''
	# ACTIVEMQ_SUNJMX_START=''\$ACTIVEMQ_SUNJMX_START -Dcom.sun.management.jmxremote.access.file=\${ACTIVEMQ_CONF}/jmx.access''
	# ACTIVEMQ_SUNJMX_START=''\$ACTIVEMQ_SUNJMX_START -Dcom.sun.management.jmxremote.ssl=false''
	ACTIVEMQ_SUNJMX_START="\$ACTIVEMQ_SUNJMX_START -Dcom.sun.management.jmxremote''
\end{lstlisting}

We obtain this
\lstset{language=Java,caption={File \texttt{activemq}},label=activemq}
\begin{lstlisting}
	...
	#
	ACTIVEMQ_SUNJMX_START=''-Dcom.sun.management.jmxremote.port=1616 ''
	ACTIVEMQ_SUNJMX_START=''$ACTIVEMQ_SUNJMX_START -Dcom.sun.management.jmxremote.authenticate=false''
	#ACTIVEMQ_SUNJMX_START=''$ACTIVEMQ_SUNJMX_START -Dcom.sun.management.jmxremote.password.file=${ACTIVEMQ_CONF}/jmx.password''
	#ACTIVEMQ_SUNJMX_START=''$ACTIVEMQ_SUNJMX_START -Dcom.sun.management.jmxremote.access.file=${ACTIVEMQ_CONF}/jmx.access''
	ACTIVEMQ_SUNJMX_START=''$ACTIVEMQ_SUNJMX_START -Dcom.sun.management.jmxremote.ssl=false''
	#ACTIVEMQ_SUNJMX_START=''$ACTIVEMQ_SUNJMX_START -Dcom.sun.management.jmxremote''

\end{lstlisting}

\subsection{How to use Master’s GUI for restart simulation}

For restart simulation there is reset button, highlighted by the red circle, see \ref{fig:mastersr}. After stoped the simulation, when the button is clicked the current simulation stops and the parameters can be edit again and the simulation can be changed or not.

\begin{figure}
\centering
\includegraphics[width=1.3\textwidth, bb=0 0 1012 300]{resetDetail.png}
\caption{Simulation reset button. \label{fig:mastersr}}
\end{figure}


\end{itemize}
\end{document}
